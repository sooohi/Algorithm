# 프로그래머스 문제 풀이

## Solution1-같은 숫자는 싫어
- 반복되는 숫자 중 하나만 넣기 위해 처음에는 arr[i]!=arr[i+1]로 비교를 했으나 배열 크기 오류가 발생
- cnt를 만들어 arr[i] != cnt 비교
- 단 여기서 0-9까지의 숫자는 입력받기 때문에 cnt는 10으로 지정

### 다른 사람의 코멘트
1. contains를 사용해 비교 할 수 있음.
2. 자바 시간복잡도 알아보기
3. arraylist는 값 읽을때만 빠름. 반대로 값 추가,삭제를 넣어야하면 linkedlist -> 이 두개에 대해 알아보기
---
## Solution2-모의고사
- 배열을 사용해 순서를 비교하려 했으나 너무 복잡해짐
- 각자 3,8,10개씩 찍는 패턴이 반복되는 것을 찾음
- 그래서 a,aa,aaa에 각각의 패턴을 저장함
- 나눠서 answers와 비교해 같다면 해당하는 cnt를 증가시킴
```C
if (a[i%5]==answers[i])
cnt[0]++;
if(aa[i%8]==answers[i])
cnt[1]++;
if(aaa[i%10]==answers[i])
cnt[2]++;
```
- max값이랑 같으면 출력을 했지만 2번 case에서 틀림
- 왜냐하면 max랑 같은 값이 예제2처럼 1개가 아닐 수 있음. 그래서 max 값 구하고 이후 한번 더 비교해서 maxlist에 저장
- intellij에서 실행한 코드랑 프로그래머스에서 실행한 코드 중 arr과 answer가 달라 생긴 기본적인 오류가 있었음

### 다른 사람의 코멘트
1. 런타임 에러가 계속 발생하였는데 int[] answer=new int[maxlist.size()];는 maxlist 한 다음 아래 선언해야함
2. 최댓값 구하는거는 -> max=Math.max(max,ab[i]);
---
## Solution3-최소직사각형
- 처음에는 가로, 세로가 고정된줄 알고 각각에서 제일 큰 값 끼리 곱해서 오류남
- 이 문제의 초점은 가로와 세로의 값이 고정된 것이 아닌, 회전이 가능하다는 것을 알게됨
- 그래서 우선 가로, 세로 구분을 안하고 가장 큰 숫자를 중점으로 삼은 후 풀려고 함.
- 하지만 계속해서 가로의 값이 세로가 되려면 세로의 값은 가로가 되어야 한다는 그런 생각때문에 어려웠음
- 그러다 둘 중 큰값들끼리 작은값은 작은 값들끼리 비교하면 되겠다고 생각 후 해결완료
- 이 부분에서 arr[i][0] arr[i][1]을 비교 후 temp에 넣어 위치를 바꾸었는데, 전에 다른 사람의 코멘트에 있던 것을 응용 -> Math.max(arr[i][0], arr[i][1]);

### 다른 사람의 코멘트
1. 자바의 경우 코드가 길어 질 수 있으므로 변수명도 신경써서 하기
2. 또 다른 방법으로 arr[i][0]과 arr[0][1]비교 arr[1][1]비교. 이런식으로 전부 비교해보는 방법도 있음
---
## Solution4-k번째 수
- answer[n]을 저장하는 부분에서 계속 오류가 발생하였음
- 위에 선언을 리스트로 했을경우는 .add를 사용해야함
- 프로그래머스에서는 int형이기때문에 내가 처음 짰던 answer[n]= list[commands[i][2]-1]로 해결하는게 맞음
- 두번째 오류는 commands[i][1]-commands[i][0]+1; answer[n]= list[commands[i][2]-1];을 해줘야 해결가능
- 이 문제를 풀면서 기본기를 더욱 튼튼하게 쌓아야겠다고 느낌,,,
- ---
## Solution5-체육복
- 여벌 옷 있는 학생이 도난당했을 때는 빌려줄 수 없어서 reserve에서 제외
- 여러개의 테스트케이스 틀림 -> lost[i]와 reserve[j]에는 0이 아닌 -1을 대입해야함. 왜냐하면 0을 대입 했을 경우 lost[i]+1 값이 1이 되서 if문으로 넘어감


### 다른 사람의 코멘트
1. int answer = n-lost.length;했더니 오류남. 이 부분은 아래 방식으로 해결함.(프로그래머스에서는 n,lost,reserve를 전부 줌).
```C
Scanner n = new Scanner(System.in);
int count = n.nextInt();
int answer = count-lost.length;
```
2. 테스트케이스 13,18오류 -> lost와 reserve가 정렬이 되지 않은 상황도 고려해야함
3. 입력받는 방법은 bufferdreader와 scanner 두 가지 있으니 공부하기 -> 전자 사용하는거 추천
---
## Solution6-기능개발
- 각 작업의 배포 일을 구한다.
- 해당 인덱스보다 작은 인덱스 까지 개수를 구한다.
- cnt에는 1을 넣어줘야함. 0으로 했을 경우 에러가 발생하는데, 왜냐하면 일은 1개로 시작하니까
---
## Solution7-폰켓몬
- 이 문제의 핵심은 중복없이 n/2만큼 최대로 가져 갈 수 있는 수를 구하는것
- cnt 배열을 만들어 nums만큼 반복하면서 0일결루 카운트를 하며, 만약 answer이 n>2보다 크면 종료한다.
- 코드 실행에서 괜찮았는데 제출만 하면 1번 케이스에서 런타임 오류 -> 폰켓몬의 종류는 2000000이하니까 cnt는 200001길리의 배열로 만듬
---
## Solution8-완주하지 못한 선수
- 우선 participant와 completion을 정렬해야함
- if(participant[i].equals(completion[i]))일 경우 continue해주고 아닐경우 출력했는데, 그러다 보니 아래에서 이중 출력되는 에러 발생
- completion의 길이는 participant의 길이보다 1 작기때문에 완주 못한 사람은 무조건 한명
- for문 동안 다르면 출력하고 종료하고 만약 끝까지 같다면 맨 마지막 배열의 사람이 미완주자
---