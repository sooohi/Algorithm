# 백준 1152, 10989, 2675,문제 풀이

## 1152 - 단어의 개수
- BufferedReader을 사용
- StringTokenizer을 사용해 " "을 기준으로 자름
- countTokens()은 StringTokenizer의 남아있는 토큰 갯수를 반환
####
- buffer을 사용하지 않고, 입력받은 문자열이 공백이면 cnt++해주는 방식으로 구현. -> 이것보다 BufferedReader을 이용하는 것이 더 효율적

## 10989 - 수 정렬하기 3
- BufferedReader을 사용해 시간 단축
- Arrays.sort 이용해 정렬
- print(arr[i])가 아닌 sb.append로 한번에 출력
####
- 런타임에러, 틀림, 시간 초과 등 다양한 오류 발생 
- 정렬 방법 간단하게 2가지(컬랙션과 배열) 공부

## 2675 - 문자열 반복
- 문자열로 받고 split메소드 이용해서 공백 기준으로 자름
- 위에서 자른 문자열을 또 한 글자씩 잘라 str에 넣음
- s[1]의 길이만큼 반복하며 r의 갯수만큼 문자 반복 출력

## 2525 - 오븐 시계
- 문자열로 받고 split메소드 이용해서 공백 기준으로 자름
- 문자열을 int형으로 변환하여 계산 

## 2750 - 수 정렬하기
- 10989의 하위 문제
- 복습해봄

## 1978 - 소수 찾기
- for문을 사용해 2부터 num까지 반복하면서 나뉘면 소수 아님
####
- 에라토스테네스의 체 공부해보기

## 1157 - 단어 공부
- 문자열 입력받은 후 charAt 사용해 string으로 저장된 문자열 중에서 한 글자만 char 타입으로 변경
- 반복문을 돌면서 해당 문자에 해당하는 배열 증가
- 대문자와 소문자는 구분 x -> 대문자는 -'A', 소문자는 -'a'
- 알파벳 26자 만큼 반복 한 후 출력 값은 대문자나 max가 같은경우 '?'로 출력
####
- 문자열의 한 글자씩 자른 것을 list에 넣어 비교하는 방식으로 작성하다가 charAt 사용함

## 2798 - 블랙잭
- for문을 3번 반복하여 sum에 arr[i],arr[j],arr[k]로 3개의 합을 넣는다.
- 처음 답이 계속 틀렸던 이유 : sum이 m보다 작으면 sum에 arr[i],arr[j],arr[k]의 합을 넣은 후 출력하니, 당연 더 큰 수가 나옴
- 그래서 max를 만들어 sum과 비교 후 적을 경우 max=sum으로 계산